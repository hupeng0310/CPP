
Manacher算法
=========

### 问题：求一个字符串的最长回文子串的长度
### 算法描述      
1. 首先通过在每个字符的两边都插入一个特殊的符号，将所有可能的奇数或偶数长度的回文子串都转换成了奇数长度。
   比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#，这样就不用考虑奇数偶数的问题了。        
2. 为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#（其实最前面特殊字符的选择可以任意，不会影响计算结果）                
3. 用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左或向右扩张的长度（包括S[i]），P[i]-1则是是原字符串中最长回文串的总长度      
4. 增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，也就是最大回文子串的边界。得到一个很重要的结论：
   如果mx > i，那么P[i] >= Min(P[2 * id - i], mx - i) 
   对于 mx <= i 的情况，因为无法对 P[i]做更多的假设，只能让P[i] = 1，然后再去匹配    	

### 关键点说明(算法描述中的第4步)
1. i的对称点i'（i'=2*id-i）为中心的回文在大的以id为中心回文串中，则i位置的回文串无需计算
![第一种情况][1]     
2. i的对称点i'为中心的回文超过大的以id为中心回文串，则i位置的回文串仍然无需计算
![第二种情况][2]     
3. i的对称点i'为中心的回文正好是大的以id为中心回文串边界，则i位置的回文串仍然无需计算
![第三种情况][3]     
4. i超过了以id为中心的回文串边界，此情况需要扩展判断了
![第四种情况][4]    
所以
mx > i，那么P[i] >= Min(P[2 * id - i], mx - i) 

  [1]: ./images/Manacher_01.png "Manacher_01.png"
  [2]: ./images/Manacher_02.png "Manacher_02.png"
  [3]: ./images/Manacher_03.png "Manacher_03.png"
  [4]: ./images/Manacher_04.png "Manacher_04.png"
