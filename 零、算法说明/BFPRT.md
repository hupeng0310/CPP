BFPRT算法
===============
### 一、介绍
<strong>BFPRT算法</strong>用于求解前k大或小的数，又称为中位数的中位数算法，时间复杂度为	O(n)
### 二、过程

 1. 求前k小元素，可以利用快排的思想，
 - (1) 将元素划分为两部分，划分的元素位置为i，
 - (2) 若是i==k,划分元素左边正好k个元素，则结束;
 - (3) 若是i<k，递归select，在划分元素右边找k-i个小的元素；
 - (4) 若是i>k，递归select，在划分元素左边找前k小的元素。
 2. 关键是划分元素的选择，快排使用的是第一个元素或最后的元素等，<strong>BFPRT算法就是解决划分元素的选择</strong>
 select过程（数组arr[n]）：
 - (1) 将n划分为n/5组，每组5个元素，最后一组n%5个元素
 - (2) 对每个组进行插入排序，排序后找到<strong>每个组的中位数</strong>,如果组内元素个数为偶数，规定找到下中位数
 - (3) 将上面找到的中位数重组为数组，即为为mArr，<strong>再找mArr的中位数</strong>记为x（即为找mArr中第mArr.length/2小的数，递归调用select即可）
 - (4)x即为找到的划分的数
 ### 三、时间复杂度为O（n）的原因
 
 1. 除了几次递归调用select的过程，时间复杂度都是**O(N)**的
 2. 上述2中(3)中递归select，数组元素为n/5,所以时间复杂度为**O(N/5)**
 3. 关键是快排思想中的划分，递归调用，为什么这么划分时间复杂度为O(N)级别***
 - 因为x是5/n个数的中位数，所以有n/10个数比x要小
 - 有因为之前5个数一组的数中有2个数要比其中的中位数小，所以有3n/10个数比x小
 - 然后取出x所在的组和最后一组（因为最后一组可能在比x小的一组中，若是最后一组只有一个元素），所以至少共有`（n/10-2）x3`个数比x小
![enter description here][1]
如上图所示
- 所以至多有`n-（n/10-2）x3=7n/10+6`个数比x要大，即右半区的最大量
- 所以整个步骤的时间复杂度为**O(7N/10+6)**

#### &nbsp; &nbsp; &nbsp; &nbsp;所以总的时间复杂度为**O(N)+O(N/5)+O(7N/10+6)**

&nbsp; &nbsp; &nbsp; &nbsp;从以上分析中可以看出，我们选取的x可以在每次递归的时候最少淘汰（n/10-2）x3的数据量


  [1]: ./images/PFPRT_01.png "PFPRT_01.png"