字符串匹配KMP算法
==============
### 一、问题描述
字符串匹配，即在字符串s中查找字符串m是否存在，返回匹配后在s中的首位置，否则返回-1 （leetcode28(Accepted). Implement strStr()）

### 二、过程
1. 求next数组，长度与字符串m一致，next[i]表示的是在**m[i]之前的字符串m[0...i-1]中**，以m[i-1]结尾的后缀子串**（不包含m[0]）**与以m[0]开头的前缀子串**（不能包含m[i-1]）**最大的匹配长度
eg:
（1）aaab的next[3]=2，因为next[3]是b之前的字符，即aaa，其最长前缀aa和最长后缀aa，所以为2
（2）123123a的next[6]=3

2. 然后进行匹配操作，如下图所示，上面的是s串，下面的是m串，假设m匹配到最后一位不匹配
![字符串匹配][1]
 则直接将m串**推到**最长后缀的开始位置，然后接着进行匹配
![字符串匹配][2]
**`[注]`**这里为什么是正确的，说明一下
![匹配过程的正确性][3]
如上图所示，假设在j处，即m串推到的位置**前面**能够往后匹配，所以图中的2中的蓝色部分能够匹配（2和3都是m串），而3中已经在b之前都匹配了，所以对应的3中蓝色部分也是匹配的，所以3中两个蓝色部分一致，但是是比绿色的部分长的，根据next数组的定义，绿色部分已经是匹配的最长前后缀了，所以这种情况不成立！

3. next数组的求法
 - next[i]的值可以借助next[i-1]的值求得，如图i处字符为a，i-1出的字符是b，要求i处的next对应值，i-1处的next对应值是知道的，假设为图中的I、K为i-1处前的最长前后缀   
 ![next数组求法][4]      
 （1）若是`b==c`，则`next[i]=next[i-1]+1`;     
 （2）若是`b!=c`,则往前跳到d（就是`cn=next[cn]`），因为I和K是相等的，所以对应的M和M'也是相等的，所以cn跳到d出，判断d是否与b相等即可
![next数组求法][5]    
 （3）若是跳到最左边，即`next[0]=-1`，则另`next[i]=0`    





  [1]: ./images/KMP_01.png "KMP_01.png"
  [2]: ./images/KMP_02.png "KMP_02.png"
  [3]: ./images/KMP_03.png "KMP_03.png"
  [4]: ./images/KMP_next_04.png "KMP_next_04.png"
  [5]: ./images/KMP_next_05.png "KMP_next_05.png"
